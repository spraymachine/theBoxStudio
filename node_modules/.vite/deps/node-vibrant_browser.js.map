{
  "version": 3,
  "sources": ["../../@vibrant/image/src/histogram.ts", "../../@vibrant/image/src/index.ts", "../../@vibrant/image-browser/src/index.ts", "../../@vibrant/core/src/utils.ts", "../../@vibrant/core/src/options.ts", "../../@vibrant/core/src/builder.ts", "../../@vibrant/core/src/pipeline/index.ts", "../../@vibrant/color/src/converter.ts", "../../@vibrant/color/src/index.ts", "../../@vibrant/core/src/index.ts", "../../node-vibrant/src/configs/config.ts", "../../node-vibrant/src/configs/browser.ts", "../../@vibrant/quantizer-mmcq/src/vbox.ts", "../../@vibrant/quantizer-mmcq/src/pqueue.ts", "../../@vibrant/quantizer-mmcq/src/index.ts", "../../@vibrant/generator-default/src/index.ts", "../../node-vibrant/src/pipeline/index.ts", "../../node-vibrant/src/browser.ts"],
  "sourcesContent": ["import type { Pixels } from \"./index\";\n\nexport interface HistogramOptions {\n\tsigBits: number;\n}\n\nexport class Histogram {\n\tbmin: number;\n\tbmax: number;\n\tgmin: number;\n\tgmax: number;\n\trmin: number;\n\trmax: number;\n\thist: Uint32Array;\n\tprivate _colorCount: number;\n\tget colorCount() {\n\t\treturn this._colorCount;\n\t}\n\tgetColorIndex: (r: number, g: number, b: number) => number;\n\tconstructor(\n\t\tpublic pixels: Pixels,\n\t\tpublic opts: HistogramOptions,\n\t) {\n\t\tconst { sigBits } = opts;\n\t\tconst getColorIndex = (r: number, g: number, b: number) =>\n\t\t\t(r << (2 * sigBits)) + (g << sigBits) + b;\n\n\t\tthis.getColorIndex = getColorIndex;\n\n\t\tconst rshift = 8 - sigBits;\n\t\tconst hn = 1 << (3 * sigBits);\n\t\tconst hist = new Uint32Array(hn);\n\t\tlet rmax: number;\n\t\tlet rmin: number;\n\t\tlet gmax: number;\n\t\tlet gmin: number;\n\t\tlet bmax: number;\n\t\tlet bmin: number;\n\t\tlet r: number;\n\t\tlet g: number;\n\t\tlet b: number;\n\t\tlet a: number;\n\t\trmax = gmax = bmax = 0;\n\t\trmin = gmin = bmin = Number.MAX_VALUE;\n\t\tconst n = pixels.length / 4;\n\t\tlet i = 0;\n\n\t\twhile (i < n) {\n\t\t\tconst offset = i * 4;\n\t\t\ti++;\n\t\t\tr = pixels[offset + 0]!;\n\t\t\tg = pixels[offset + 1]!;\n\t\t\tb = pixels[offset + 2]!;\n\t\t\ta = pixels[offset + 3]!;\n\n\t\t\t// Ignored pixels' alpha is marked as 0 in filtering stage\n\t\t\tif (a === 0) continue;\n\n\t\t\tr = r >> rshift;\n\t\t\tg = g >> rshift;\n\t\t\tb = b >> rshift;\n\n\t\t\tconst index = getColorIndex(r, g, b);\n\t\t\tif (hist[index] === undefined) hist[index] = 0;\n\t\t\thist[index] += 1;\n\n\t\t\tif (r > rmax) rmax = r;\n\t\t\tif (r < rmin) rmin = r;\n\t\t\tif (g > gmax) gmax = g;\n\t\t\tif (g < gmin) gmin = g;\n\t\t\tif (b > bmax) bmax = b;\n\t\t\tif (b < bmin) bmin = b;\n\t\t}\n\t\tthis._colorCount = hist.reduce(\n\t\t\t(total, c) => (c > 0 ? total + 1 : total),\n\t\t\t0,\n\t\t);\n\t\tthis.hist = hist;\n\t\tthis.rmax = rmax;\n\t\tthis.rmin = rmin;\n\t\tthis.gmax = gmax;\n\t\tthis.gmin = gmin;\n\t\tthis.bmax = bmax;\n\t\tthis.bmin = bmin;\n\t}\n}\n", "import type { Filter } from \"@vibrant/color\";\n\nexport { Histogram } from \"./histogram\";\nexport type { HistogramOptions } from \"./histogram\";\n\n/**\n * HTMLImageElement - browser only\n * Buffer - Node.js only\n */\nexport type ImageSource = string | HTMLImageElement | Buffer;\n\nexport type Pixels = Uint8ClampedArray | Buffer;\nexport interface ImageData {\n\tdata: Pixels;\n\twidth: number;\n\theight: number;\n}\n\nexport interface ImageOptions {\n\t/**\n\t * Scale down factor used in downsampling stage. 1 means no downsampling. If `maxDimension` is set, this value will not be used.\n\t * @default 5\n\t */\n\tquality: number;\n\t/**\n\t * The max size of the image's longer side used in downsampling stage. This field will override `quality`.\n\t * @default undefined\n\t */\n\tmaxDimension: number;\n}\n\nexport interface Image {\n\tload(image: ImageSource): Promise<Image>;\n\tclear(): void;\n\tupdate(imageData: ImageData): void;\n\tgetWidth(): number;\n\tgetHeight(): number;\n\tresize(targetWidth: number, targetHeight: number, ratio: number): void;\n\tgetPixelCount(): number;\n\tgetImageData(): ImageData;\n\tremove(): void;\n\tscaleDown(opts: ImageOptions): void;\n}\n\nexport interface ImageClass {\n\tnew (): Image;\n}\n\nexport abstract class ImageBase implements Image {\n\tabstract load(image: ImageSource): Promise<ImageBase>;\n\tabstract clear(): void;\n\tabstract update(imageData: ImageData): void;\n\tabstract getWidth(): number;\n\tabstract getHeight(): number;\n\tabstract resize(\n\t\ttargetWidth: number,\n\t\ttargetHeight: number,\n\t\tratio: number,\n\t): void;\n\tabstract getPixelCount(): number;\n\tabstract getImageData(): ImageData;\n\tabstract remove(): void;\n\n\tscaleDown(opts: ImageOptions): void {\n\t\tconst width: number = this.getWidth();\n\t\tconst height: number = this.getHeight();\n\n\t\tlet ratio = 1;\n\n\t\tif (opts.maxDimension > 0) {\n\t\t\tconst maxSide: number = Math.max(width, height);\n\t\t\tif (maxSide > opts.maxDimension) ratio = opts.maxDimension / maxSide;\n\t\t} else {\n\t\t\tratio = 1 / opts.quality;\n\t\t}\n\n\t\tif (ratio < 1) this.resize(width * ratio, height * ratio, ratio);\n\t}\n}\n\n/**\n * @private\n */\nexport function applyFilters(imageData: ImageData, filters: Filter[]) {\n\tif (filters.length > 0) {\n\t\tconst pixels = imageData.data;\n\t\tconst n = pixels.length / 4;\n\t\tlet offset;\n\t\tlet r;\n\t\tlet g;\n\t\tlet b;\n\t\tlet a;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\toffset = i * 4;\n\t\t\tr = pixels[offset + 0]!;\n\t\t\tg = pixels[offset + 1]!;\n\t\t\tb = pixels[offset + 2]!;\n\t\t\ta = pixels[offset + 3]!;\n\t\t\t// Mark ignored color\n\t\t\tfor (let j = 0; j < filters.length; j++) {\n\t\t\t\tif (!filters[j]?.(r, g, b, a)) {\n\t\t\t\t\tpixels[offset + 3] = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn imageData;\n}\n", "import { ImageBase } from \"@vibrant/image\";\nimport type {\n\tImageSource,\n\tImageData as VibrantImageData,\n} from \"@vibrant/image\";\n\nfunction isRelativeUrl(url: string): boolean {\n\tconst u = new URL(url, location.href);\n\treturn (\n\t\tu.protocol === location.protocol &&\n\t\tu.host === location.host &&\n\t\tu.port === location.port\n\t);\n}\n\nfunction isSameOrigin(a: string, b: string): boolean {\n\tconst ua = new URL(a);\n\tconst ub = new URL(b);\n\n\t// https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\n\treturn (\n\t\tua.protocol === ub.protocol &&\n\t\tua.hostname === ub.hostname &&\n\t\tua.port === ub.port\n\t);\n}\n\nexport class BrowserImage extends ImageBase {\n\timage: HTMLImageElement | undefined;\n\tprivate _canvas: HTMLCanvasElement | undefined;\n\tprivate _context: CanvasRenderingContext2D | undefined;\n\tprivate _width: number | undefined;\n\tprivate _height: number | undefined;\n\n\tprivate _getCanvas() {\n\t\tif (!this._canvas) {\n\t\t\tthrow new Error(\"Canvas is not initialized\");\n\t\t}\n\n\t\treturn this._canvas;\n\t}\n\tprivate _getContext() {\n\t\tif (!this._context) {\n\t\t\tthrow new Error(\"Context is not initialized\");\n\t\t}\n\n\t\treturn this._context;\n\t}\n\tprivate _getWidth() {\n\t\tif (!this._width) {\n\t\t\tthrow new Error(\"Width is not initialized\");\n\t\t}\n\n\t\treturn this._width;\n\t}\n\tprivate _getHeight() {\n\t\tif (!this._height) {\n\t\t\tthrow new Error(\"Height is not initialized\");\n\t\t}\n\n\t\treturn this._height;\n\t}\n\n\tprivate _initCanvas(): void {\n\t\tconst img = this.image;\n\t\tif (!img) {\n\t\t\tthrow new Error(\"Image is not initialized\");\n\t\t}\n\t\tconst canvas = (this._canvas = document.createElement(\"canvas\"));\n\t\tconst context = canvas.getContext(\"2d\");\n\n\t\tif (!context) throw new ReferenceError(\"Failed to create canvas context\");\n\n\t\tthis._context = context;\n\n\t\tcanvas.className = \"@vibrant/canvas\";\n\t\tcanvas.style.display = \"none\";\n\n\t\tthis._width = canvas.width = img.width;\n\t\tthis._height = canvas.height = img.height;\n\n\t\tcontext.drawImage(img, 0, 0);\n\n\t\tdocument.body.appendChild(canvas);\n\t}\n\n\tload(image: ImageSource): Promise<this> {\n\t\tlet img: HTMLImageElement;\n\t\tlet src: string;\n\t\tif (typeof image === \"string\") {\n\t\t\timg = document.createElement(\"img\");\n\t\t\tsrc = image;\n\n\t\t\tif (!isRelativeUrl(src) && !isSameOrigin(window.location.href, src)) {\n\t\t\t\timg.crossOrigin = \"anonymous\";\n\t\t\t}\n\n\t\t\timg.src = src;\n\t\t} else if (image instanceof HTMLImageElement) {\n\t\t\timg = image;\n\t\t\tsrc = image.src;\n\t\t} else {\n\t\t\treturn Promise.reject(\n\t\t\t\tnew Error(`Cannot load buffer as an image in browser`),\n\t\t\t);\n\t\t}\n\t\tthis.image = img;\n\n\t\treturn new Promise<this>((resolve, reject) => {\n\t\t\tconst onImageLoad = () => {\n\t\t\t\tthis._initCanvas();\n\t\t\t\tresolve(this);\n\t\t\t};\n\n\t\t\tif (img.complete) {\n\t\t\t\t// Already loaded\n\t\t\t\tonImageLoad();\n\t\t\t} else {\n\t\t\t\timg.onload = onImageLoad;\n\t\t\t\timg.onerror = (_e) => reject(new Error(`Fail to load image: ${src}`));\n\t\t\t}\n\t\t});\n\t}\n\n\tclear(): void {\n\t\tthis._getContext().clearRect(0, 0, this._getWidth(), this._getHeight());\n\t}\n\n\tupdate(imageData: VibrantImageData): void {\n\t\tthis._getContext().putImageData(imageData as ImageData, 0, 0);\n\t}\n\n\tgetWidth(): number {\n\t\treturn this._getWidth();\n\t}\n\n\tgetHeight(): number {\n\t\treturn this._getHeight();\n\t}\n\n\tresize(targetWidth: number, targetHeight: number, ratio: number): void {\n\t\tif (!this.image) {\n\t\t\tthrow new Error(\"Image is not initialized\");\n\t\t}\n\t\tthis._width = this._getCanvas().width = targetWidth;\n\t\tthis._height = this._getCanvas().height = targetHeight;\n\n\t\tthis._getContext().scale(ratio, ratio);\n\t\tthis._getContext().drawImage(this.image, 0, 0);\n\t}\n\n\tgetPixelCount(): number {\n\t\treturn this._getWidth() * this._getHeight();\n\t}\n\n\tgetImageData(): ImageData {\n\t\treturn this._getContext().getImageData(\n\t\t\t0,\n\t\t\t0,\n\t\t\tthis._getWidth(),\n\t\t\tthis._getHeight(),\n\t\t);\n\t}\n\n\tremove(): void {\n\t\tif (this._canvas && this._canvas.parentNode) {\n\t\t\tthis._canvas.parentNode.removeChild(this._canvas);\n\t\t}\n\t}\n}\n", "/**\n * @private\n */\nexport function mapValues<T, R>(\n\to: { [key: string]: T },\n\tmapper: (v: T) => R,\n): { [key: string]: R } {\n\tconst result: { [key: string]: R } = {};\n\n\tfor (const key in o) {\n\t\tif (o.hasOwnProperty(key)) {\n\t\t\tconst v = o[key];\n\t\t\tif (!v) continue;\n\t\t\tresult[key] = mapper(v);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * @private\n * Overwrite values or properties on objects and lists recursively.\n * A shallow copy will be created for each array value.\n */\nexport function assignDeep<T>(\n\ttarget: Partial<T>,\n\t...sources: (Partial<T> | undefined)[]\n): T {\n\tsources.forEach((s) => {\n\t\tif (!s) return;\n\t\tfor (const key in s) {\n\t\t\tif (s.hasOwnProperty(key)) {\n\t\t\t\tconst v = s[key] as any;\n\t\t\t\tif (Array.isArray(v)) {\n\t\t\t\t\t// Shallow copy\n\t\t\t\t\ttarget[key] = v.slice(0) as any;\n\t\t\t\t} else if (typeof v === \"object\") {\n\t\t\t\t\tif (!target[key]) target[key] = {} as any;\n\t\t\t\t\tassignDeep<any>(target[key] as any, v);\n\t\t\t\t} else {\n\t\t\t\t\ttarget[key] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\treturn target as T;\n}\n", "import { Filter, Palette, Swatch } from \"@vibrant/color\";\nimport { Image, ImageSource } from \"@vibrant/image\";\nimport { Quantizer } from \"@vibrant/quantizer\";\nimport { Generator } from \"@vibrant/generator\";\nimport { assignDeep } from \"./utils\";\nimport type { ProcessOptions, StageOptions } from \"./pipeline\";\nimport type { QuantizerOptions } from \"@vibrant/quantizer\";\nimport type { ImageClass, ImageOptions } from \"@vibrant/image\";\n\nexport interface Options extends ImageOptions, QuantizerOptions {\n\tuseWorker: boolean;\n\t/**\n\t * An `Image` implementation class\n\t * @default `Image.Node` or `Image.Browser`\n\t */\n\tImageClass: ImageClass;\n\tquantizer: string | StageOptions;\n\tgenerators: (string | StageOptions)[];\n\t/**\n\t * An array of filters\n\t * @default []\n\t */\n\tfilters: string[];\n}\n\n/**\n * @private\n */\nexport function buildProcessOptions(\n\topts: Options,\n\toverride?: Partial<ProcessOptions>,\n): ProcessOptions {\n\tconst { colorCount, quantizer, generators, filters } = opts;\n\t// Merge with common quantizer options\n\tconst commonQuantizerOpts = { colorCount };\n\tconst q =\n\t\ttypeof quantizer === \"string\"\n\t\t\t? { name: quantizer, options: {} }\n\t\t\t: quantizer;\n\tq.options = assignDeep({}, commonQuantizerOpts, q.options);\n\n\treturn assignDeep(\n\t\t{},\n\t\t{\n\t\t\tquantizer: q,\n\t\t\tgenerators,\n\t\t\tfilters,\n\t\t},\n\t\toverride,\n\t);\n}\n", "import { assignDeep } from \"./utils\";\nimport { Vibrant } from \"./\";\nimport type { ImageClass, ImageSource } from \"@vibrant/image\";\n\nimport type { Palette } from \"@vibrant/color\";\nimport type { Options } from \"./options\";\n\n/**\n * Helper class for change configurations and create a Vibrant instance. Methods of a Builder instance can be chained like:\n *\n * @example\n * ```javascript\n * Vibrant.from(src)\n *   .quality(1)\n *   .clearFilters()\n *   // ...\n *   .getPalette()\n *   .then((palette) => {})\n * ```\n */\nexport class Builder {\n\tprivate _src: ImageSource;\n\tprivate _opts: Partial<Options>;\n\n\t/**\n\t * Arguments are the same as `Vibrant.constructor`.\n\t */\n\tconstructor(src: ImageSource, opts: Partial<Options> = {}) {\n\t\tthis._src = src;\n\t\tthis._opts = assignDeep({}, Vibrant.DefaultOpts, opts);\n\t}\n\n\t/**\n\t * Sets `opts.colorCount` to `n`.\n\t * @returns this `Builder` instance.\n\t */\n\tmaxColorCount(n: number): Builder {\n\t\tthis._opts.colorCount = n;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets `opts.maxDimension` to `d`.\n\t * @returns this `Builder` instance.\n\t */\n\tmaxDimension(d: number): Builder {\n\t\tthis._opts.maxDimension = d;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a filter function\n\t * @returns this `Builder` instance.\n\t */\n\taddFilter(name: string): Builder {\n\t\tif (!this._opts.filters) {\n\t\t\tthis._opts.filters = [name];\n\t\t} else {\n\t\t\tthis._opts.filters.push(name);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes a filter function.\n\t * @returns this `Builder` instance.\n\t */\n\tremoveFilter(name: string): Builder {\n\t\tif (this._opts.filters) {\n\t\t\tconst i = this._opts.filters.indexOf(name);\n\t\t\tif (i > 0) this._opts.filters.splice(i);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clear all filters.\n\t * @returns this `Builder` instance.\n\t */\n\tclearFilters(): Builder {\n\t\tthis._opts.filters = [];\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets `opts.quality` to `q`.\n\t * @returns this `Builder` instance.\n\t */\n\tquality(q: number): Builder {\n\t\tthis._opts.quality = q;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specifies which `Image` implementation class to use.\n\t * @returns this `Builder` instance.\n\t */\n\tuseImageClass(imageClass: ImageClass): Builder {\n\t\tthis._opts.ImageClass = imageClass;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets `opts.generator` to `generator`\n\t * @returns this `Builder` instance.\n\t */\n\tuseGenerator(generator: string, options?: any): Builder {\n\t\tif (!this._opts.generators) this._opts.generators = [];\n\t\tthis._opts.generators.push(\n\t\t\toptions ? { name: generator, options } : generator,\n\t\t);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Specifies which `Quantizer` implementation class to use\n\t * @returns this `Builder` instance.\n\t */\n\tuseQuantizer(quantizer: string, options?: any): Builder {\n\t\tthis._opts.quantizer = options ? { name: quantizer, options } : quantizer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Builds and returns a `Vibrant` instance as configured.\n\t */\n\tbuild(): Vibrant {\n\t\treturn new Vibrant(this._src, this._opts);\n\t}\n\n\t/**\n\t * Builds a `Vibrant` instance as configured and calls its `getPalette` method.\n\t */\n\tgetPalette(): Promise<Palette> {\n\t\treturn this.build().getPalette();\n\t}\n}\n", "import { applyFilters } from \"@vibrant/image\";\nimport type { ImageData } from \"@vibrant/image\";\nimport type { Quantizer } from \"@vibrant/quantizer\";\nimport type { Generator } from \"@vibrant/generator\";\nimport type { Filter, Palette, Swatch } from \"@vibrant/color\";\n\n/**\n * @private\n */\nexport class Stage<T> {\n\tprivate _map: { [name: string]: T } = {};\n\tconstructor(protected pipeline: BasicPipeline) {}\n\tnames() {\n\t\treturn Object.keys(this._map);\n\t}\n\thas(name: string) {\n\t\treturn !!this._map[name];\n\t}\n\tget(name: string) {\n\t\treturn this._map[name];\n\t}\n\tregister(name: string, stageFn: T) {\n\t\tthis._map[name] = stageFn;\n\t\treturn this.pipeline;\n\t}\n}\n\n/**\n * @private\n */\nexport interface ProcessResult {\n\tcolors: Swatch[];\n\tpalettes: { [name: string]: Palette };\n}\n\n/**\n * @private\n */\nexport interface StageOptions {\n\tname: string;\n\toptions?: any;\n}\n\n/**\n * @private\n */\nexport interface ProcessOptions {\n\tfilters: string[];\n\tquantizer: string | StageOptions;\n\tgenerators: (string | StageOptions)[];\n}\n\n/**\n * @private\n */\ninterface StageTask<Q> {\n\tname: string;\n\tfn: Q;\n\toptions?: any;\n}\n\n/**\n * @private\n */\ninterface ProcessTasks {\n\tfilters: StageTask<Filter>[];\n\tquantizer: StageTask<Quantizer>;\n\tgenerators: StageTask<Generator>[];\n}\n\n/**\n * @private\n */\nexport interface Pipeline {\n\t// quantizer: Stage<Quantizer>\n\t// generator: Stage<Generator>\n\tprocess(imageData: ImageData, opts: ProcessOptions): Promise<ProcessResult>;\n}\n\n/**\n * @private\n */\nexport class BasicPipeline implements Pipeline {\n\tprivate _buildProcessTasks({\n\t\tfilters,\n\t\tquantizer,\n\t\tgenerators,\n\t}: ProcessOptions): ProcessTasks {\n\t\t// Support wildcard for generators\n\t\tif (generators.length === 1 && generators[0] === \"*\") {\n\t\t\tgenerators = this.generator.names();\n\t\t}\n\t\treturn {\n\t\t\tfilters: filters.map((f) => createTask(this.filter, f)),\n\t\t\tquantizer: createTask(this.quantizer, quantizer),\n\t\t\tgenerators: generators.map((g) => createTask(this.generator, g)),\n\t\t};\n\t\tfunction createTask<Q>(\n\t\t\tstage: Stage<Q>,\n\t\t\to: string | StageOptions,\n\t\t): StageTask<Q> {\n\t\t\tlet name: string;\n\t\t\tlet options: any;\n\t\t\tif (typeof o === \"string\") {\n\t\t\t\tname = o;\n\t\t\t} else {\n\t\t\t\tname = o.name;\n\t\t\t\toptions = o.options;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tname,\n\t\t\t\tfn: stage.get(name)!,\n\t\t\t\toptions,\n\t\t\t};\n\t\t}\n\t}\n\tfilter: Stage<Filter> = new Stage(this);\n\tquantizer: Stage<Quantizer> = new Stage(this);\n\tgenerator: Stage<Generator> = new Stage(this);\n\tasync process(\n\t\timageData: ImageData,\n\t\topts: ProcessOptions,\n\t): Promise<ProcessResult> {\n\t\tconst { filters, quantizer, generators } = this._buildProcessTasks(opts);\n\t\tconst imageFilterData = await this._filterColors(filters, imageData);\n\t\tconst colors = await this._generateColors(quantizer, imageFilterData);\n\t\tconst palettes = await this._generatePalettes(generators, colors);\n\t\treturn {\n\t\t\tcolors,\n\t\t\tpalettes,\n\t\t};\n\t}\n\tprivate _filterColors(filters: StageTask<Filter>[], imageData: ImageData) {\n\t\treturn Promise.resolve(\n\t\t\tapplyFilters(\n\t\t\t\timageData,\n\t\t\t\tfilters.map(({ fn }) => fn),\n\t\t\t),\n\t\t);\n\t}\n\tprivate _generateColors(\n\t\tquantizer: StageTask<Quantizer>,\n\t\timageData: ImageData,\n\t) {\n\t\treturn Promise.resolve(quantizer.fn(imageData.data, quantizer.options));\n\t}\n\tprivate async _generatePalettes(\n\t\tgenerators: StageTask<Generator>[],\n\t\tcolors: Swatch[],\n\t) {\n\t\t// Make a promise map that will run them \"concurrently\" (but return in expected result)\n\t\tconst promiseArr = await Promise.all(\n\t\t\tgenerators.map(({ fn, options }) => Promise.resolve(fn(colors, options))),\n\t\t);\n\t\t// Map the values to the expected name\n\t\treturn Promise.resolve(\n\t\t\tpromiseArr.reduce(\n\t\t\t\t(promises, promiseVal, i) => {\n\t\t\t\t\tpromises[generators[i]!.name] = promiseVal;\n\t\t\t\t\treturn promises;\n\t\t\t\t},\n\t\t\t\t{} as { [name: string]: Palette },\n\t\t\t),\n\t\t);\n\t}\n}\n", "import type { Vec3 } from \"./\";\n\nexport const DELTAE94_DIFF_STATUS = {\n\tNA: 0,\n\tPERFECT: 1,\n\tCLOSE: 2,\n\tGOOD: 10,\n\tSIMILAR: 50,\n};\n\n/**\n * Converts hex string to RGB\n * @param hex - The hex value you with to get the RGB value of\n * @returns an array in the order of `red, green, blue` numerical values\n */\nexport function hexToRgb(hex: string): Vec3 {\n\tconst m = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n\n\tif (!m) throw new RangeError(`'${hex}' is not a valid hex color`);\n\n\tif (!m[1] || !m[2] || !m[3])\n\t\tthrow new RangeError(`'${hex}' is not a valid hex color`);\n\n\treturn [m[1], m[2], m[3]].map((s) => parseInt(s, 16)) as Vec3;\n}\n\n/**\n * Given values for an RGB color convert to and return a valid HEX string\n * @param r - Red value in RGB\n * @param g - Green value in RGB\n * @param b - Blue value in RGB\n * @returns a valid hex string with pre-pending pound sign\n */\nexport function rgbToHex(r: number, g: number, b: number): string {\n\treturn \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1, 7);\n}\n\n/**\n * Given values for an RGB color convert to and return a valid HSL value\n * @param r - Red value in RGB\n * @param g - Green value in RGB\n * @param b - Blue value in RGB\n * @returns an array in the order of `hue, saturation, light` numerical values\n */\nexport function rgbToHsl(r: number, g: number, b: number): Vec3 {\n\tr /= 255;\n\tg /= 255;\n\tb /= 255;\n\tconst max = Math.max(r, g, b);\n\tconst min = Math.min(r, g, b);\n\tlet h = 0;\n\tlet s = 0;\n\tconst l = (max + min) / 2;\n\tif (max !== min) {\n\t\tconst d = max - min;\n\t\ts = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n\t\tswitch (max) {\n\t\t\tcase r:\n\t\t\t\th = (g - b) / d + (g < b ? 6 : 0);\n\t\t\t\tbreak;\n\t\t\tcase g:\n\t\t\t\th = (b - r) / d + 2;\n\t\t\t\tbreak;\n\t\t\tcase b:\n\t\t\t\th = (r - g) / d + 4;\n\t\t\t\tbreak;\n\t\t}\n\n\t\th /= 6;\n\t}\n\treturn [h, s, l];\n}\n\nexport function hslToRgb(h: number, s: number, l: number): Vec3 {\n\tlet r: number;\n\tlet g: number;\n\tlet b: number;\n\n\tfunction hue2rgb(p: number, q: number, t: number): number {\n\t\tif (t < 0) t += 1;\n\t\tif (t > 1) t -= 1;\n\t\tif (t < 1 / 6) return p + (q - p) * 6 * t;\n\t\tif (t < 1 / 2) return q;\n\t\tif (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n\t\treturn p;\n\t}\n\n\tif (s === 0) {\n\t\tr = g = b = l;\n\t} else {\n\t\tconst q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n\t\tconst p = 2 * l - q;\n\t\tr = hue2rgb(p, q, h + 1 / 3);\n\t\tg = hue2rgb(p, q, h);\n\t\tb = hue2rgb(p, q, h - 1 / 3);\n\t}\n\treturn [r * 255, g * 255, b * 255];\n}\n\nexport function rgbToXyz(r: number, g: number, b: number): Vec3 {\n\tr /= 255;\n\tg /= 255;\n\tb /= 255;\n\tr = r > 0.04045 ? Math.pow((r + 0.005) / 1.055, 2.4) : r / 12.92;\n\tg = g > 0.04045 ? Math.pow((g + 0.005) / 1.055, 2.4) : g / 12.92;\n\tb = b > 0.04045 ? Math.pow((b + 0.005) / 1.055, 2.4) : b / 12.92;\n\n\tr *= 100;\n\tg *= 100;\n\tb *= 100;\n\n\tconst x = r * 0.4124 + g * 0.3576 + b * 0.1805;\n\tconst y = r * 0.2126 + g * 0.7152 + b * 0.0722;\n\tconst z = r * 0.0193 + g * 0.1192 + b * 0.9505;\n\n\treturn [x, y, z];\n}\n\nexport function xyzToCIELab(x: number, y: number, z: number): Vec3 {\n\tconst REF_X = 95.047;\n\tconst REF_Y = 100;\n\tconst REF_Z = 108.883;\n\n\tx /= REF_X;\n\ty /= REF_Y;\n\tz /= REF_Z;\n\n\tx = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;\n\ty = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;\n\tz = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;\n\n\tconst L = 116 * y - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [L, a, b];\n}\n\nexport function rgbToCIELab(r: number, g: number, b: number): Vec3 {\n\tconst [x, y, z] = rgbToXyz(r, g, b);\n\treturn xyzToCIELab(x, y, z);\n}\n\n/**\n * Computes CIE delta E 1994 diff between `lab1` and `lab2`. The 2 colors are in CIE-Lab color space. Used in tests to compare 2 colors' perceptual similarity.\n */\nexport function deltaE94(lab1: Vec3, lab2: Vec3): number {\n\tconst WEIGHT_L = 1;\n\tconst WEIGHT_C = 1;\n\tconst WEIGHT_H = 1;\n\n\tconst [L1, a1, b1] = lab1;\n\tconst [L2, a2, b2] = lab2;\n\tconst dL = L1 - L2;\n\tconst da = a1 - a2;\n\tconst db = b1 - b2;\n\n\tconst xC1 = Math.sqrt(a1 * a1 + b1 * b1);\n\tconst xC2 = Math.sqrt(a2 * a2 + b2 * b2);\n\n\tlet xDL = L2 - L1;\n\tlet xDC = xC2 - xC1;\n\tconst xDE = Math.sqrt(dL * dL + da * da + db * db);\n\n\tlet xDH =\n\t\tMath.sqrt(xDE) > Math.sqrt(Math.abs(xDL)) + Math.sqrt(Math.abs(xDC))\n\t\t\t? Math.sqrt(xDE * xDE - xDL * xDL - xDC * xDC)\n\t\t\t: 0;\n\n\tconst xSC = 1 + 0.045 * xC1;\n\tconst xSH = 1 + 0.015 * xC1;\n\n\txDL /= WEIGHT_L;\n\txDC /= WEIGHT_C * xSC;\n\txDH /= WEIGHT_H * xSH;\n\n\treturn Math.sqrt(xDL * xDL + xDC * xDC + xDH * xDH);\n}\n\n/**\n * Compute CIE delta E 1994 diff between `rgb1` and `rgb2`.\n */\nexport function rgbDiff(rgb1: Vec3, rgb2: Vec3): number {\n\tconst lab1 = rgbToCIELab.apply(undefined, rgb1);\n\tconst lab2 = rgbToCIELab.apply(undefined, rgb2);\n\treturn deltaE94(lab1, lab2);\n}\n\n/**\n * Compute CIE delta E 1994 diff between `hex1` and `hex2`.\n */\nexport function hexDiff(hex1: string, hex2: string): number {\n\tconst rgb1 = hexToRgb(hex1);\n\tconst rgb2 = hexToRgb(hex2);\n\n\treturn rgbDiff(rgb1, rgb2);\n}\n\n/**\n * Gets a string to describe the meaning of the color diff. Used in tests.\n *\n * Delta E  | Perception                             | Returns\n * -------- | -------------------------------------- | -----------\n * <= 1.0   | Not perceptible by human eyes.         | `\"Perfect\"`\n * 1 - 2    | Perceptible through close observation. | `\"Close\"`\n * 2 - 10   | Perceptible at a glance.               | `\"Good\"`\n * 11 - 49  | Colors are more similar than opposite  | `\"Similar\"`\n * 50 - 100 | Colors are exact opposite              | `Wrong`\n */\nexport function getColorDiffStatus(d: number): string {\n\tif (d < DELTAE94_DIFF_STATUS.NA) {\n\t\treturn \"N/A\";\n\t}\n\t// Not perceptible by human eyes\n\tif (d <= DELTAE94_DIFF_STATUS.PERFECT) {\n\t\treturn \"Perfect\";\n\t}\n\t// Perceptible through close observation\n\tif (d <= DELTAE94_DIFF_STATUS.CLOSE) {\n\t\treturn \"Close\";\n\t}\n\t// Perceptible at a glance\n\tif (d <= DELTAE94_DIFF_STATUS.GOOD) {\n\t\treturn \"Good\";\n\t}\n\t// Colors are more similar than opposite\n\tif (d < DELTAE94_DIFF_STATUS.SIMILAR) {\n\t\treturn \"Similar\";\n\t}\n\treturn \"Wrong\";\n}\n", "import { rgbToHex, rgbToHsl } from \"./converter\";\n\nexport * from \"./converter\";\n\n/**\n * @returns `true` if the color is to be kept.\n */\nexport interface Filter {\n\t(red: number, green: number, blue: number, alpha: number): boolean;\n}\n\n/**\n * 3d floating pointer vector\n */\nexport type Vec3 = [number, number, number];\n\n/**\n * The layout for a node-vibrant Palette. Allows you to keep track of\n */\nexport interface Palette {\n\tVibrant: Swatch | null;\n\tMuted: Swatch | null;\n\tDarkVibrant: Swatch | null;\n\tDarkMuted: Swatch | null;\n\tLightVibrant: Swatch | null;\n\tLightMuted: Swatch | null;\n\t// ?\n\t[name: string]: Swatch | null;\n}\n\n/**\n * Represents a color swatch generated from an image's palette.\n */\nexport class Swatch {\n\tstatic applyFilters(colors: Swatch[], filters: Filter[]): Swatch[] {\n\t\treturn filters.length > 0\n\t\t\t? colors.filter(({ r, g, b }) => {\n\t\t\t\t\tfor (let j = 0; j < filters.length; j++) {\n\t\t\t\t\t\tif (!filters[j]?.(r, g, b, 255)) return false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t})\n\t\t\t: colors;\n\t}\n\n\t/**\n\t * Make a value copy of a swatch based on a previous one. Returns a new Swatch instance\n\t * @param {Swatch} swatch\n\t */\n\tstatic clone(swatch: Swatch) {\n\t\treturn new Swatch(swatch._rgb, swatch._population);\n\t}\n\tprivate _rgb: Vec3;\n\tprivate _population: number;\n\tprivate _hsl: Vec3 | undefined;\n\tprivate _yiq: number | undefined;\n\tprivate _hex: string | undefined;\n\n\t/**\n\t * The red value in the RGB value\n\t */\n\tget r(): number {\n\t\treturn this._rgb[0];\n\t}\n\t/**\n\t * The green value in the RGB value\n\t */\n\tget g(): number {\n\t\treturn this._rgb[1];\n\t}\n\t/**\n\t * The blue value in the RGB value\n\t */\n\tget b(): number {\n\t\treturn this._rgb[2];\n\t}\n\t/**\n\t * The color value as a rgb value\n\t */\n\tget rgb(): Vec3 {\n\t\treturn this._rgb;\n\t}\n\t/**\n\t * The color value as a hsl value\n\t */\n\tget hsl(): Vec3 {\n\t\tif (!this._hsl) {\n\t\t\tconst [r, g, b] = this._rgb;\n\t\t\tthis._hsl = rgbToHsl(r, g, b);\n\t\t}\n\t\treturn this._hsl;\n\t}\n\n\t/**\n\t * The color value as a hex string\n\t */\n\tget hex(): string {\n\t\tif (!this._hex) {\n\t\t\tconst [r, g, b] = this._rgb;\n\t\t\tthis._hex = rgbToHex(r, g, b);\n\t\t}\n\t\treturn this._hex;\n\t}\n\n\tget population(): number {\n\t\treturn this._population;\n\t}\n\n\t/**\n\t * Get the JSON object for the swatch\n\t */\n\ttoJSON(): { rgb: Vec3; population: number } {\n\t\treturn {\n\t\t\trgb: this.rgb,\n\t\t\tpopulation: this.population,\n\t\t};\n\t}\n\n\tprivate getYiq(): number {\n\t\tif (!this._yiq) {\n\t\t\tconst rgb = this._rgb;\n\t\t\tthis._yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;\n\t\t}\n\t\treturn this._yiq;\n\t}\n\n\tprivate _titleTextColor: string | undefined;\n\tprivate _bodyTextColor: string | undefined;\n\n\t/**\n\t * Returns an appropriate color to use for any 'title' text which is displayed over this Swatch's color.\n\t */\n\tget titleTextColor() {\n\t\tif (!this._titleTextColor) {\n\t\t\tthis._titleTextColor = this.getYiq() < 200 ? \"#fff\" : \"#000\";\n\t\t}\n\t\treturn this._titleTextColor;\n\t}\n\n\t/**\n\t * Returns an appropriate color to use for any 'body' text which is displayed over this Swatch's color.\n\t */\n\tget bodyTextColor() {\n\t\tif (!this._bodyTextColor) {\n\t\t\tthis._bodyTextColor = this.getYiq() < 150 ? \"#fff\" : \"#000\";\n\t\t}\n\t\treturn this._bodyTextColor;\n\t}\n\n\t/**\n\t * Internal use.\n\t * @param rgb `[r, g, b]`\n\t * @param population Population of the color in an image\n\t */\n\tconstructor(rgb: Vec3, population: number) {\n\t\tthis._rgb = rgb;\n\t\tthis._population = population;\n\t}\n}\n", "import { buildProcessOptions } from \"./options\";\nimport { Builder } from \"./builder\";\nimport { assignDeep } from \"./utils\";\nimport type { Options } from \"./options\";\nimport type { Image, ImageSource } from \"@vibrant/image\";\n\nimport type { Palette } from \"@vibrant/color\";\n\nimport type { Pipeline, ProcessOptions, ProcessResult } from \"./pipeline\";\n\n/**\n * Main class of `node-vibrant`.\n */\nexport class Vibrant {\n\tprivate _result: ProcessResult | undefined;\n\tprivate static _pipeline: Pipeline;\n\n\tstatic use(pipeline: Pipeline) {\n\t\tthis._pipeline = pipeline;\n\t}\n\n\tstatic DefaultOpts: Partial<Options> = {\n\t\tcolorCount: 64,\n\t\tquality: 5,\n\t\tfilters: [],\n\t};\n\n\tstatic from(src: ImageSource): Builder {\n\t\treturn new Builder(src);\n\t}\n\n\tget result() {\n\t\treturn this._result;\n\t}\n\n\topts: Options;\n\n\t/**\n\t *\n\t * @param _src Path to image file (supports HTTP/HTTPs)\n\t * @param opts Options (optional)\n\t */\n\tconstructor(\n\t\tprivate _src: ImageSource,\n\t\topts?: Partial<Options>,\n\t) {\n\t\tthis.opts = assignDeep({}, Vibrant.DefaultOpts, opts);\n\t}\n\n\tprivate _process(\n\t\timage: Image,\n\t\topts?: Partial<ProcessOptions>,\n\t): Promise<ProcessResult> {\n\t\timage.scaleDown(this.opts);\n\n\t\tconst processOpts = buildProcessOptions(this.opts, opts);\n\n\t\treturn Vibrant._pipeline.process(image.getImageData(), processOpts);\n\t}\n\n\tasync getPalette(): Promise<Palette> {\n\t\tconst image = new this.opts.ImageClass();\n\t\ttry {\n\t\t\tconst image1 = await image.load(this._src);\n\t\t\tconst result1: ProcessResult = await this._process(image1, {\n\t\t\t\tgenerators: [\"default\"],\n\t\t\t});\n\t\t\tthis._result = result1;\n\t\t\tconst res = result1.palettes[\"default\"];\n\t\t\tif (!res) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Something went wrong and a palette was not found, please file a bug against our GitHub repo: https://github.com/vibrant-Colors/node-vibrant/`,\n\t\t\t\t);\n\t\t\t}\n\t\t\timage.remove();\n\t\t\treturn res;\n\t\t} catch (err) {\n\t\t\timage.remove();\n\t\t\treturn Promise.reject(err);\n\t\t}\n\t}\n\n\tasync getPalettes(): Promise<{ [name: string]: Palette }> {\n\t\tconst image = new this.opts.ImageClass();\n\t\ttry {\n\t\t\tconst image1 = await image.load(this._src);\n\t\t\tconst result1: ProcessResult = await this._process(image1, {\n\t\t\t\tgenerators: [\"*\"],\n\t\t\t});\n\t\t\tthis._result = result1;\n\t\t\tconst res: any = result1.palettes;\n\t\t\timage.remove();\n\t\t\treturn res;\n\t\t} catch (err) {\n\t\t\timage.remove();\n\t\t\treturn Promise.reject(err);\n\t\t}\n\t}\n}\n\nexport { BasicPipeline } from \"./pipeline\";\nexport { WorkerPipeline } from \"./pipeline/worker/client\";\nexport { runPipelineInWorker } from \"./pipeline/worker/host\";\nexport { Builder };\n", "import { Vibrant } from \"@vibrant/core\";\n\nVibrant.DefaultOpts.quantizer = \"mmcq\";\nVibrant.DefaultOpts.generators = [\"default\"];\nVibrant.DefaultOpts.filters = [\"default\"];\n\nexport { Vibrant };\n", "import { BrowserImage } from \"@vibrant/image-browser\";\nimport { Vibrant } from \"./config\";\n\nVibrant.DefaultOpts.ImageClass = BrowserImage;\n\nexport { Vibrant };\n", "import { Filter } from \"@vibrant/color\";\nimport { Histogram } from \"@vibrant/image\";\nimport type { Vec3 } from \"@vibrant/color\";\nimport type { Pixels } from \"@vibrant/image\";\n\ninterface Dimension {\n\tr1: number;\n\tr2: number;\n\tg1: number;\n\tg2: number;\n\tb1: number;\n\tb2: number;\n\t[d: string]: number;\n}\n\nconst SIGBITS = 5;\nconst RSHIFT = 8 - SIGBITS;\n\n/**\n * @private\n */\nexport class VBox {\n\tstatic build(pixels: Pixels): VBox {\n\t\tconst h = new Histogram(pixels, { sigBits: SIGBITS });\n\t\tconst { rmin, rmax, gmin, gmax, bmin, bmax } = h;\n\t\treturn new VBox(rmin, rmax, gmin, gmax, bmin, bmax, h);\n\t}\n\n\tdimension: Dimension;\n\n\tprivate _volume = -1;\n\tprivate _avg: Vec3 | null = null;\n\tprivate _count = -1;\n\n\tconstructor(\n\t\tr1: number,\n\t\tr2: number,\n\t\tg1: number,\n\t\tg2: number,\n\t\tb1: number,\n\t\tb2: number,\n\t\tpublic histogram: Histogram,\n\t) {\n\t\t// NOTE: dimension will be mutated by split operation.\n\t\t//       It must be specified explicitly, not from histogram\n\t\tthis.dimension = { r1, r2, g1, g2, b1, b2 };\n\t}\n\n\tinvalidate(): void {\n\t\tthis._volume = this._count = -1;\n\t\tthis._avg = null;\n\t}\n\n\tvolume(): number {\n\t\tif (this._volume < 0) {\n\t\t\tconst { r1, r2, g1, g2, b1, b2 } = this.dimension;\n\t\t\tthis._volume = (r2 - r1 + 1) * (g2 - g1 + 1) * (b2 - b1 + 1);\n\t\t}\n\t\treturn this._volume;\n\t}\n\n\tcount(): number {\n\t\tif (this._count < 0) {\n\t\t\tconst { hist, getColorIndex } = this.histogram;\n\t\t\tconst { r1, r2, g1, g2, b1, b2 } = this.dimension;\n\t\t\tlet c = 0;\n\n\t\t\tfor (let r = r1; r <= r2; r++) {\n\t\t\t\tfor (let g = g1; g <= g2; g++) {\n\t\t\t\t\tfor (let b = b1; b <= b2; b++) {\n\t\t\t\t\t\tconst index = getColorIndex(r, g, b);\n\t\t\t\t\t\tif (!hist[index]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc += hist[index]!;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._count = c;\n\t\t}\n\t\treturn this._count;\n\t}\n\n\tclone(): VBox {\n\t\tconst { histogram } = this;\n\t\tconst { r1, r2, g1, g2, b1, b2 } = this.dimension;\n\t\treturn new VBox(r1, r2, g1, g2, b1, b2, histogram);\n\t}\n\n\tavg(): Vec3 {\n\t\tif (!this._avg) {\n\t\t\tconst { hist, getColorIndex } = this.histogram;\n\t\t\tconst { r1, r2, g1, g2, b1, b2 } = this.dimension;\n\t\t\tlet ntot = 0;\n\t\t\tconst mult = 1 << (8 - SIGBITS);\n\t\t\tlet rsum: number;\n\t\t\tlet gsum: number;\n\t\t\tlet bsum: number;\n\t\t\trsum = gsum = bsum = 0;\n\n\t\t\tfor (let r = r1; r <= r2; r++) {\n\t\t\t\tfor (let g = g1; g <= g2; g++) {\n\t\t\t\t\tfor (let b = b1; b <= b2; b++) {\n\t\t\t\t\t\tconst index = getColorIndex(r, g, b);\n\t\t\t\t\t\tconst h = hist[index];\n\t\t\t\t\t\tif (!h) continue;\n\t\t\t\t\t\tntot += h;\n\t\t\t\t\t\trsum += h * (r + 0.5) * mult;\n\t\t\t\t\t\tgsum += h * (g + 0.5) * mult;\n\t\t\t\t\t\tbsum += h * (b + 0.5) * mult;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ntot) {\n\t\t\t\tthis._avg = [~~(rsum / ntot), ~~(gsum / ntot), ~~(bsum / ntot)];\n\t\t\t} else {\n\t\t\t\tthis._avg = [\n\t\t\t\t\t~~((mult * (r1 + r2 + 1)) / 2),\n\t\t\t\t\t~~((mult * (g1 + g2 + 1)) / 2),\n\t\t\t\t\t~~((mult * (b1 + b2 + 1)) / 2),\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\t\treturn this._avg;\n\t}\n\n\tcontains(rgb: Vec3): boolean {\n\t\tlet [r, g, b] = rgb;\n\t\tconst { r1, r2, g1, g2, b1, b2 } = this.dimension;\n\t\tr >>= RSHIFT;\n\t\tg >>= RSHIFT;\n\t\tb >>= RSHIFT;\n\n\t\treturn r >= r1 && r <= r2 && g >= g1 && g <= g2 && b >= b1 && b <= b2;\n\t}\n\n\tsplit(): VBox[] {\n\t\tconst { hist, getColorIndex } = this.histogram;\n\t\tconst { r1, r2, g1, g2, b1, b2 } = this.dimension;\n\t\tconst count = this.count();\n\t\tif (!count) return [];\n\t\tif (count === 1) return [this.clone()];\n\t\tconst rw = r2 - r1 + 1;\n\t\tconst gw = g2 - g1 + 1;\n\t\tconst bw = b2 - b1 + 1;\n\n\t\tconst maxw = Math.max(rw, gw, bw);\n\t\tlet accSum: Uint32Array | null = null;\n\t\tlet sum: number;\n\t\tlet total: number;\n\t\tsum = total = 0;\n\n\t\tlet maxd: \"r\" | \"g\" | \"b\" | null = null;\n\n\t\tif (maxw === rw) {\n\t\t\tmaxd = \"r\";\n\t\t\taccSum = new Uint32Array(r2 + 1);\n\t\t\tfor (let r = r1; r <= r2; r++) {\n\t\t\t\tsum = 0;\n\t\t\t\tfor (let g = g1; g <= g2; g++) {\n\t\t\t\t\tfor (let b = b1; b <= b2; b++) {\n\t\t\t\t\t\tconst index = getColorIndex(r, g, b);\n\t\t\t\t\t\tif (!hist[index]) continue;\n\t\t\t\t\t\tsum += hist[index]!;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttotal += sum;\n\t\t\t\taccSum[r] = total;\n\t\t\t}\n\t\t} else if (maxw === gw) {\n\t\t\tmaxd = \"g\";\n\t\t\taccSum = new Uint32Array(g2 + 1);\n\t\t\tfor (let g = g1; g <= g2; g++) {\n\t\t\t\tsum = 0;\n\t\t\t\tfor (let r = r1; r <= r2; r++) {\n\t\t\t\t\tfor (let b = b1; b <= b2; b++) {\n\t\t\t\t\t\tconst index = getColorIndex(r, g, b);\n\t\t\t\t\t\tif (!hist[index]) continue;\n\t\t\t\t\t\tsum += hist[index]!;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttotal += sum;\n\t\t\t\taccSum[g] = total;\n\t\t\t}\n\t\t} else {\n\t\t\tmaxd = \"b\";\n\t\t\taccSum = new Uint32Array(b2 + 1);\n\t\t\tfor (let b = b1; b <= b2; b++) {\n\t\t\t\tsum = 0;\n\t\t\t\tfor (let r = r1; r <= r2; r++) {\n\t\t\t\t\tfor (let g = g1; g <= g2; g++) {\n\t\t\t\t\t\tconst index = getColorIndex(r, g, b);\n\t\t\t\t\t\tif (!hist[index]) continue;\n\t\t\t\t\t\tsum += hist[index]!;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttotal += sum;\n\t\t\t\taccSum[b] = total;\n\t\t\t}\n\t\t}\n\n\t\tlet splitPoint = -1;\n\t\tconst reverseSum = new Uint32Array(accSum.length);\n\t\tfor (let i = 0; i < accSum.length; i++) {\n\t\t\tconst d = accSum[i];\n\t\t\tif (!d) continue;\n\t\t\tif (splitPoint < 0 && d > total / 2) splitPoint = i;\n\t\t\treverseSum[i] = total - d;\n\t\t}\n\n\t\tconst vbox = this;\n\n\t\tfunction doCut(d: string): VBox[] {\n\t\t\tconst dim1 = d + \"1\";\n\t\t\tconst dim2 = d + \"2\";\n\t\t\tconst d1 = vbox.dimension[dim1]!;\n\t\t\tlet d2 = vbox.dimension[dim2]!;\n\t\t\tconst vbox1 = vbox.clone();\n\t\t\tconst vbox2 = vbox.clone();\n\t\t\tconst left = splitPoint - d1;\n\t\t\tconst right = d2 - splitPoint;\n\n\t\t\tif (left <= right) {\n\t\t\t\td2 = Math.min(d2 - 1, ~~(splitPoint + right / 2));\n\t\t\t\td2 = Math.max(0, d2);\n\t\t\t} else {\n\t\t\t\td2 = Math.max(d1, ~~(splitPoint - 1 - left / 2));\n\t\t\t\td2 = Math.min(vbox.dimension[dim2]!, d2);\n\t\t\t}\n\n\t\t\twhile (!accSum![d2]) d2++;\n\n\t\t\tlet c2 = reverseSum[d2];\n\t\t\twhile (!c2 && accSum![d2 - 1]) c2 = reverseSum[--d2];\n\n\t\t\tvbox1.dimension[dim2] = d2;\n\t\t\tvbox2.dimension[dim1] = d2 + 1;\n\n\t\t\treturn [vbox1, vbox2];\n\t\t}\n\n\t\treturn doCut(maxd);\n\t}\n}\n", "interface PQueueComparator<T> {\n\t(a: T, b: T): number;\n}\n\n/**\n * @private\n */\nexport class PQueue<T> {\n\tcontents: T[];\n\tprivate _sorted: boolean;\n\tprivate _comparator: PQueueComparator<T>;\n\tprivate _sort(): void {\n\t\tif (!this._sorted) {\n\t\t\tthis.contents.sort(this._comparator);\n\t\t\tthis._sorted = true;\n\t\t}\n\t}\n\n\tconstructor(comparator: PQueueComparator<T>) {\n\t\tthis._comparator = comparator;\n\t\tthis.contents = [];\n\t\tthis._sorted = false;\n\t}\n\n\tpush(item: T): void {\n\t\tthis.contents.push(item);\n\t\tthis._sorted = false;\n\t}\n\n\tpeek(index?: number): T {\n\t\tthis._sort();\n\t\tindex = typeof index === \"number\" ? index : this.contents.length - 1;\n\t\treturn this.contents[index]!;\n\t}\n\n\tpop() {\n\t\tthis._sort();\n\t\treturn this.contents.pop();\n\t}\n\n\tsize(): number {\n\t\treturn this.contents.length;\n\t}\n\n\tmap<U>(mapper: (item: T, index: number) => any): U[] {\n\t\tthis._sort();\n\t\treturn this.contents.map(mapper);\n\t}\n}\n", "import { Quantizer } from \"@vibrant/quantizer\";\nimport { Filter, Swatch } from \"@vibrant/color\";\nimport { VBox } from \"./vbox\";\nimport { PQueue } from \"./pqueue\";\nimport type { Pixels } from \"@vibrant/image\";\nimport type { QuantizerOptions } from \"@vibrant/quantizer\";\n\nconst fractByPopulations = 0.75;\n\nfunction _splitBoxes(pq: PQueue<VBox>, target: number): void {\n\tlet lastSize = pq.size();\n\twhile (pq.size() < target) {\n\t\tconst vbox = pq.pop();\n\n\t\tif (vbox && vbox.count() > 0) {\n\t\t\tconst [vbox1, vbox2] = vbox.split();\n\n\t\t\tif (!vbox1) break;\n\n\t\t\tpq.push(vbox1);\n\t\t\tif (vbox2 && vbox2.count() > 0) pq.push(vbox2);\n\n\t\t\t// No more new boxes, converged\n\t\t\tif (pq.size() === lastSize) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tlastSize = pq.size();\n\t\t\t}\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport const MMCQ = (pixels: Pixels, opts: QuantizerOptions): Array<Swatch> => {\n\tif (pixels.length === 0 || opts.colorCount < 2 || opts.colorCount > 256) {\n\t\tthrow new Error(\"Wrong MMCQ parameters\");\n\t}\n\n\tconst vbox = VBox.build(pixels);\n\tconst colorCount = vbox.histogram.colorCount;\n\tconst pq = new PQueue<VBox>((a, b) => a.count() - b.count());\n\n\tpq.push(vbox);\n\n\t// first set of colors, sorted by population\n\t_splitBoxes(pq, fractByPopulations * opts.colorCount);\n\n\t// Re-order\n\tconst pq2 = new PQueue<VBox>(\n\t\t(a, b) => a.count() * a.volume() - b.count() * b.volume(),\n\t);\n\tpq2.contents = pq.contents;\n\n\t// next set - generate the median cuts using the (npix * vol) sorting.\n\t_splitBoxes(pq2, opts.colorCount - pq2.size());\n\n\t// calculate the actual colors\n\treturn generateSwatches(pq2);\n};\n\nfunction generateSwatches(pq: PQueue<VBox>) {\n\tconst swatches: Swatch[] = [];\n\twhile (pq.size()) {\n\t\tconst v = pq.pop()!;\n\t\tconst color = v.avg();\n\t\tconst [r, g, b] = color;\n\t\tswatches.push(new Swatch(color, v.count()));\n\t}\n\treturn swatches;\n}\n", "/* eslint-disable prefer-const, @typescript-eslint/no-unnecessary-condition */\nimport { Swatch, hslToRgb } from \"@vibrant/color\";\nimport type { Generator } from \"@vibrant/generator\";\nimport type { Palette } from \"@vibrant/color\";\n\nexport interface GeneratorOptions {\n\ttargetDarkLuma: number;\n\tmaxDarkLuma: number;\n\tminLightLuma: number;\n\ttargetLightLuma: number;\n\tminNormalLuma: number;\n\ttargetNormalLuma: number;\n\tmaxNormalLuma: number;\n\ttargetMutesSaturation: number;\n\tmaxMutesSaturation: number;\n\ttargetVibrantSaturation: number;\n\tminVibrantSaturation: number;\n\tweightSaturation: number;\n\tweightLuma: number;\n\tweightPopulation: number;\n}\n\nexport const DefaultOpts: GeneratorOptions = {\n\ttargetDarkLuma: 0.26,\n\tmaxDarkLuma: 0.45,\n\tminLightLuma: 0.55,\n\ttargetLightLuma: 0.74,\n\tminNormalLuma: 0.3,\n\ttargetNormalLuma: 0.5,\n\tmaxNormalLuma: 0.7,\n\ttargetMutesSaturation: 0.3,\n\tmaxMutesSaturation: 0.4,\n\ttargetVibrantSaturation: 1.0,\n\tminVibrantSaturation: 0.35,\n\tweightSaturation: 3,\n\tweightLuma: 6.5,\n\tweightPopulation: 0.5,\n};\n\nfunction _findMaxPopulation(swatches: Array<Swatch>): number {\n\tlet p = 0;\n\n\tswatches.forEach((s) => {\n\t\tp = Math.max(p, s.population);\n\t});\n\n\treturn p;\n}\n\nfunction _isAlreadySelected(palette: Palette, s: Swatch): boolean {\n\treturn (\n\t\tpalette.Vibrant === s ||\n\t\tpalette.DarkVibrant === s ||\n\t\tpalette.LightVibrant === s ||\n\t\tpalette.Muted === s ||\n\t\tpalette.DarkMuted === s ||\n\t\tpalette.LightMuted === s\n\t);\n}\n\nfunction _createComparisonValue(\n\tsaturation: number,\n\ttargetSaturation: number,\n\tluma: number,\n\ttargetLuma: number,\n\tpopulation: number,\n\tmaxPopulation: number,\n\topts: GeneratorOptions,\n): number {\n\tfunction weightedMean(...values: number[]) {\n\t\tlet sum = 0;\n\t\tlet weightSum = 0;\n\t\tfor (let i = 0; i < values.length; i += 2) {\n\t\t\tconst value = values[i];\n\t\t\tconst weight = values[i + 1];\n\t\t\tif (!value || !weight) continue;\n\t\t\tsum += value * weight;\n\t\t\tweightSum += weight;\n\t\t}\n\n\t\treturn sum / weightSum;\n\t}\n\n\tfunction invertDiff(value: number, targetValue: number): number {\n\t\treturn 1 - Math.abs(value - targetValue);\n\t}\n\n\treturn weightedMean(\n\t\tinvertDiff(saturation, targetSaturation),\n\t\topts.weightSaturation,\n\t\tinvertDiff(luma, targetLuma),\n\t\topts.weightLuma,\n\t\tpopulation / maxPopulation,\n\t\topts.weightPopulation,\n\t);\n}\n\nfunction _findColorVariation(\n\tpalette: Palette,\n\tswatches: Array<Swatch>,\n\tmaxPopulation: number,\n\ttargetLuma: number,\n\tminLuma: number,\n\tmaxLuma: number,\n\ttargetSaturation: number,\n\tminSaturation: number,\n\tmaxSaturation: number,\n\topts: GeneratorOptions,\n): Swatch | null {\n\tlet max: Swatch | null = null;\n\tlet maxValue = 0;\n\n\tswatches.forEach((swatch) => {\n\t\tconst [, s, l] = swatch.hsl;\n\n\t\tif (\n\t\t\ts >= minSaturation &&\n\t\t\ts <= maxSaturation &&\n\t\t\tl >= minLuma &&\n\t\t\tl <= maxLuma &&\n\t\t\t!_isAlreadySelected(palette, swatch)\n\t\t) {\n\t\t\tconst value = _createComparisonValue(\n\t\t\t\ts,\n\t\t\t\ttargetSaturation,\n\t\t\t\tl,\n\t\t\t\ttargetLuma,\n\t\t\t\tswatch.population,\n\t\t\t\tmaxPopulation,\n\t\t\t\topts,\n\t\t\t);\n\n\t\t\tif (max === null || value > maxValue) {\n\t\t\t\tmax = swatch;\n\t\t\t\tmaxValue = value;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn max;\n}\n\nfunction _generateVariationColors(\n\tswatches: Array<Swatch>,\n\tmaxPopulation: number,\n\topts: GeneratorOptions,\n): Palette {\n\tconst palette: Palette = {\n\t\tVibrant: null,\n\t\tDarkVibrant: null,\n\t\tLightVibrant: null,\n\t\tMuted: null,\n\t\tDarkMuted: null,\n\t\tLightMuted: null,\n\t};\n\t// mVibrantSwatch = findColor(TARGET_NORMAL_LUMA, MIN_NORMAL_LUMA, MAX_NORMAL_LUMA,\n\t//     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n\tpalette.Vibrant = _findColorVariation(\n\t\tpalette,\n\t\tswatches,\n\t\tmaxPopulation,\n\t\topts.targetNormalLuma,\n\t\topts.minNormalLuma,\n\t\topts.maxNormalLuma,\n\t\topts.targetVibrantSaturation,\n\t\topts.minVibrantSaturation,\n\t\t1,\n\t\topts,\n\t);\n\t// mLightVibrantSwatch = findColor(TARGET_LIGHT_LUMA, MIN_LIGHT_LUMA, 1f,\n\t//     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n\tpalette.LightVibrant = _findColorVariation(\n\t\tpalette,\n\t\tswatches,\n\t\tmaxPopulation,\n\t\topts.targetLightLuma,\n\t\topts.minLightLuma,\n\t\t1,\n\t\topts.targetVibrantSaturation,\n\t\topts.minVibrantSaturation,\n\t\t1,\n\t\topts,\n\t);\n\t// mDarkVibrantSwatch = findColor(TARGET_DARK_LUMA, 0f, MAX_DARK_LUMA,\n\t//     TARGET_VIBRANT_SATURATION, MIN_VIBRANT_SATURATION, 1f)\n\tpalette.DarkVibrant = _findColorVariation(\n\t\tpalette,\n\t\tswatches,\n\t\tmaxPopulation,\n\t\topts.targetDarkLuma,\n\t\t0,\n\t\topts.maxDarkLuma,\n\t\topts.targetVibrantSaturation,\n\t\topts.minVibrantSaturation,\n\t\t1,\n\t\topts,\n\t);\n\t// mMutedSwatch = findColor(TARGET_NORMAL_LUMA, MIN_NORMAL_LUMA, MAX_NORMAL_LUMA,\n\t//     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n\tpalette.Muted = _findColorVariation(\n\t\tpalette,\n\t\tswatches,\n\t\tmaxPopulation,\n\t\topts.targetNormalLuma,\n\t\topts.minNormalLuma,\n\t\topts.maxNormalLuma,\n\t\topts.targetMutesSaturation,\n\t\t0,\n\t\topts.maxMutesSaturation,\n\t\topts,\n\t);\n\t// mLightMutedColor = findColor(TARGET_LIGHT_LUMA, MIN_LIGHT_LUMA, 1f,\n\t//     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n\tpalette.LightMuted = _findColorVariation(\n\t\tpalette,\n\t\tswatches,\n\t\tmaxPopulation,\n\t\topts.targetLightLuma,\n\t\topts.minLightLuma,\n\t\t1,\n\t\topts.targetMutesSaturation,\n\t\t0,\n\t\topts.maxMutesSaturation,\n\t\topts,\n\t);\n\t// mDarkMutedSwatch = findColor(TARGET_DARK_LUMA, 0f, MAX_DARK_LUMA,\n\t//     TARGET_MUTED_SATURATION, 0f, MAX_MUTED_SATURATION)\n\tpalette.DarkMuted = _findColorVariation(\n\t\tpalette,\n\t\tswatches,\n\t\tmaxPopulation,\n\t\topts.targetDarkLuma,\n\t\t0,\n\t\topts.maxDarkLuma,\n\t\topts.targetMutesSaturation,\n\t\t0,\n\t\topts.maxMutesSaturation,\n\t\topts,\n\t);\n\treturn palette;\n}\n\nfunction _generateEmptySwatches(\n\tpalette: Palette,\n\t_maxPopulation: number,\n\topts: GeneratorOptions,\n): void {\n\tif (!palette.Vibrant && !palette.DarkVibrant && !palette.LightVibrant) {\n\t\tif (!palette.DarkVibrant && palette.DarkMuted) {\n\t\t\tlet [h, s, l] = palette.DarkMuted.hsl;\n\t\t\tl = opts.targetDarkLuma;\n\t\t\tpalette.DarkVibrant = new Swatch(hslToRgb(h, s, l), 0);\n\t\t}\n\t\tif (!palette.LightVibrant && palette.LightMuted) {\n\t\t\tlet [h, s, l] = palette.LightMuted.hsl;\n\t\t\tl = opts.targetDarkLuma;\n\t\t\tpalette.DarkVibrant = new Swatch(hslToRgb(h, s, l), 0);\n\t\t}\n\t}\n\tif (!palette.Vibrant && palette.DarkVibrant) {\n\t\tlet [h, s, l] = palette.DarkVibrant.hsl;\n\t\tl = opts.targetNormalLuma;\n\t\tpalette.Vibrant = new Swatch(hslToRgb(h, s, l), 0);\n\t} else if (!palette.Vibrant && palette.LightVibrant) {\n\t\tlet [h, s, l] = palette.LightVibrant.hsl;\n\t\tl = opts.targetNormalLuma;\n\t\tpalette.Vibrant = new Swatch(hslToRgb(h, s, l), 0);\n\t}\n\tif (!palette.DarkVibrant && palette.Vibrant) {\n\t\tlet [h, s, l] = palette.Vibrant.hsl;\n\t\tl = opts.targetDarkLuma;\n\t\tpalette.DarkVibrant = new Swatch(hslToRgb(h, s, l), 0);\n\t}\n\tif (!palette.LightVibrant && palette.Vibrant) {\n\t\tlet [h, s, l] = palette.Vibrant.hsl;\n\t\tl = opts.targetLightLuma;\n\t\tpalette.LightVibrant = new Swatch(hslToRgb(h, s, l), 0);\n\t}\n\tif (!palette.Muted && palette.Vibrant) {\n\t\tlet [h, s, l] = palette.Vibrant.hsl;\n\t\tl = opts.targetMutesSaturation;\n\t\tpalette.Muted = new Swatch(hslToRgb(h, s, l), 0);\n\t}\n\tif (!palette.DarkMuted && palette.DarkVibrant) {\n\t\tlet [h, s, l] = palette.DarkVibrant.hsl;\n\t\tl = opts.targetMutesSaturation;\n\t\tpalette.DarkMuted = new Swatch(hslToRgb(h, s, l), 0);\n\t}\n\tif (!palette.LightMuted && palette.LightVibrant) {\n\t\tlet [h, s, l] = palette.LightVibrant.hsl;\n\t\tl = opts.targetMutesSaturation;\n\t\tpalette.LightMuted = new Swatch(hslToRgb(h, s, l), 0);\n\t}\n}\n\nexport const DefaultGenerator: Generator = ((\n\tswatches: Array<Swatch>,\n\topts?: GeneratorOptions,\n): Palette => {\n\topts = Object.assign({}, DefaultOpts, opts);\n\tconst maxPopulation = _findMaxPopulation(swatches);\n\n\tconst palette = _generateVariationColors(swatches, maxPopulation, opts);\n\t_generateEmptySwatches(palette, maxPopulation, opts);\n\n\treturn palette;\n}) as never;\n", "import { MMCQ } from \"@vibrant/quantizer-mmcq\";\nimport { DefaultGenerator } from \"@vibrant/generator-default\";\n\nimport { BasicPipeline } from \"@vibrant/core\";\n\nexport const pipeline = new BasicPipeline().filter\n\t.register(\n\t\t\"default\",\n\t\t(r: number, g: number, b: number, a: number) =>\n\t\t\ta >= 125 && !(r > 250 && g > 250 && b > 250),\n\t)\n\t.quantizer.register(\"mmcq\", MMCQ)\n\t.generator.register(\"default\", DefaultGenerator);\n", "import { Vibrant } from \"./configs/browser\";\nimport { pipeline } from \"./pipeline\";\n\nVibrant.use(pipeline);\n\nexport { Vibrant };\n"],
  "mappings": "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",
  "names": ["r", "g", "b", "pipeline", "_Vibrant", "pipeline"]
}
